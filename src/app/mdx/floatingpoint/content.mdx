## 0.1 + 0.2, 한 번 확인해보세요

JavaScript 개발자 도구나 브라우저 콘솔을 열어보세요.

**0.1 + 0.2**를 입력해보면 ?

아마 아래 이미지와 같이 `0.30000000000000004` 같은 이상한 숫자가 나왔을 겁니다.

<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/0.1%2B0.2.png"
  width="600"
/>

이건 버그가 아니라 컴퓨터의 아주 **'정상적인'** 동작입니다.

> **💡 계산기 앱에서는 0.3이 나옵니다 !** <br/>
> 계산기 앱들은 사용자 편의를 위해 **반올림**을 해주거든요. <br/>
> 하지만, 내부적으로는 여전히 부정확한 값으로 저장되어 있습니다.

### 컴퓨터에게 0.1이란?

우리에게는 아주 간단한 0.1이지만, <br/>
컴퓨터에게는 전혀 간단하지 않습니다.

10진법에서 1/3이 0.333... 이 되는 것처럼, <br/>
**2진법에서 0.1은 0.000110011001100110011...** 이 됩니다.

0.0 다음으로 끝없이 0011이 반복되는 순환소수입니다.

#### 0.1을 2진법으로 변환

10진법 0.1을 2진법으로 변환해보면,

```
0.1 × 2 = 0.2 → 정수부: 0
0.2 × 2 = 0.4 → 정수부: 0  
0.4 × 2 = 0.8 → 정수부: 0
0.8 × 2 = 1.6 → 정수부: 1
0.6 × 2 = 1.2 → 정수부: 1
0.2 × 2 = 0.4 → 정수부: 0 (반복 시작)
0.4 × 2 = 0.8 → 정수부: 0
0.8 × 2 = 1.6 → 정수부: 1
0.6 × 2 = 1.2 → 정수부: 1
...
```

결과: `0.000110011001100110011...`

이 패턴이 영원히 반복됩니다.

### 다른 소수들은 어떨까?

| 10진법 | 2진법 | 정확히 표현 가능한가? |
|--------|-------|------------------|
| 0.5 | 0.1 | ✅ |
| 0.25 | 0.01 | ✅ |
| 0.125 | 0.001 | ✅ |
| 0.1 | 0.000110011... | ❌ |
| 0.2 | 0.001100110011... | ❌ |
| 0.3 | 0.010011001100... | ❌ |

**규칙** : 분모가 2의 거듭제곱인 분수들만 2진법에서 정확히 표현됩니다.
- 1/2 = 0.5 → ✅
- 1/4 = 0.25 → ✅ 
- 1/5 = 0.2 → ❌
- 1/10 = 0.1 → ❌

사실 이 문제는 아주 오래전 컴퓨터가 아닌 인류로부터 시작되었습니다.

---

## 완벽을 추구했던 인류, 타협해야 했던 컴퓨터

기원전 5세기, 피타고라스 학파의 수학자들은 충격적인 발견을 했습니다. 

<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/pythagorean.svg"
  width="500"
/>

중학교 때 배운 **a² + b² = c²**

한 변의 길이가 1인 정사각형의 대각선 길이를 구해보면,

```
1² + 1² = c²
2 = c²
c = √2
```

그런데 √2를 계산해보면, 1.414213562373095... 처럼 끝없이 이어지는 숫자가 나오게 됩니다.

**"이 숫자는 끝이 있나?"**

이 숫자가 절대 끝나지 않는 **무리수**라는 사실을 우리는 알고 있습니다. <br/>
하지만, 이 **끝나지 않는 숫자**가 컴퓨터를 괴롭히게 될 거라는 사실은 몰랐었죠.

수학자들은 오랫동안 무리수에 대해 완벽한 계산을 꿈꿨습니다.<br/>
**원주율 π = 3.14159265358979...** 을 소수점 아래 수백, 수천 자리까지 계산해가며 <br/>
"언젠가는 정확한 값을 구할 수 있을 거야"라고 믿었죠.

하지만 컴퓨터가 등장하면서 공학자, 엔지니어들은 현실적인 문제에 직면했습니다.

**"컴퓨터에 무한한 숫자인 무리수를 어떻게 저장을 해야하지... "**

### 사실 우리도 이미 타협을 하고 있다

생각해보면, 우리도 일상에서 계속 반올림해서 사용하고 있습니다.

원의 둘레를 구할 때 π = 3.14159265... 대신에 그냥 **3.14**로 계산하고,<br/>
√2 = 1.41421356... 대신 그냥 **1.41**로 쓰죠.

계산기로 10 ÷ 3을 하면 3.333333... 이 나오지만, <br/>
실제로는 **3.33** 정도로 반올림해서 사용하고 있습니다.

**정확한 값을 사용하려고 해도 사실 불가능해요.**

우리 일상에서도 보면,

- **화폐**: 1원 단위 (0.1원은 없음)
- **시간**: 스톱워치의 최소 측정 단위는 0.01초
- **길이**: 자의 최소 눈금은 1mm
- **무게**: 일반적인 저울도 0.1g, 0.01g까지만 측정

이처럼, 무리수인 π = 3.14159265358979... 를 정확하게 사용하고 싶어도, <br/>
물리적 한계 때문에 **3.14** 정도로 반올림할 수밖에 없습니다.

우리도 이미 **무한한 숫자를 유한하게 타협**해서 사용하고 있었던 것입니다 !

### 컴퓨터도 마찬가지입니다

위에서 그랬듯, 우리는 π(파이)나 √2 같은 무리수를 정확히 표현할 수 없어 "3.14", "1.41"처럼 몇 자리까지만 잘라서 근사해서 씁니다.

컴퓨터도 마찬가지입니다. <br/>
무한한 숫자를 유한한 비트로 저장해야 하기 때문에, <br/>
항상 **'딱 떨어지지 않는 수'를 근사해서 표현**합니다.

그런데 컴퓨터에겐 한 가지 더 큰 제약이 있습니다.

> **오직 2진법만 사용한다는 점입니다**

이게 왜 문제일까?

예를 들어, **0.1**은 우리가 보기에 그저 간단한 유리수이고, <br/>
10진법에선 `0.1`이라는 깔끔한 소수로 표현됩니다.

하지만 컴퓨터가 이걸 **2진법으로 바꾸려는 순간**, <br/>
`0.000110011001100...` 처럼 **끝없이 반복되는 순환소수**가 되어버립니다. <br/>
(마치 10진법에서 1/3 = 0.333…)

결국 컴퓨터는 **0.1을 정확히 표현하지 못하고**, <br/>
가까운 수치로 근사할 수밖에 없습니다.

---

## IEEE 754, 전 세계가 합의한 '불완전한' 표준

**IEEE 754**는 1985년 미국 전기전자학회(IEEE)에서 제정한 부동소수점 수의 표현 및 연산에 대한 표준입니다.

이 표준은 다양한 컴퓨터 시스템 간의 부동소수점 연산 호환성을 높이고, 부동소수점 연산의 정확성과 안정성을 확보하기 위해 만들어졌습니다.

> "완벽한 계산은 포기하고, 대신 모든 컴퓨터가 같은 방식으로 **근사**하자."

**"부동소수점의 아버지"** 라고 불리는 윌리엄 카한(William Kahan)을 비롯한 많은 엔지니어들이 참여한 이 표준은, 현재 거의 모든 컴퓨터 시스템에서 실수를 표현하는 데 사용되는 사실상의 표준이 되었습니다.

### 과학적 표기법의 2진법 버전

우리가 아는 과학적 표기법을 기억해보면,

```
123,000,000 = 1.23 × 10⁸
```

IEEE 754도 비슷한 방식입니다. 다만 2진법을 사용해요.

```
1.101 × 2³ (2진법 버전)
```

### 32비트 부동소수점 구조

32비트 부동소수점은 다음과 같이 구성됩니다.

<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/32bit_Float.png"
  width="800"
/>

#### 각 필드의 역할

**1. 부호 비트 (Sign bit)**
- 0 : 양수
- 1 : 음수

**2. 지수 부분 (Exponent, 8비트)**
- 실제 지수에 127을 더한 값 (바이어스된 지수)
- 범위 : 0~255
- 실제 지수 범위 : -126~127

**3. 분수 부분 (Fraction, 23비트)**
- 소수점 이하 부분만 저장
- 정규화된 수에서는 암묵적으로 1.이 앞에 붙음

### 0.1을 IEEE 754로 저장하기

0.1을 32비트 IEEE 754 형식으로 저장한다면,

#### 1. 2진법으로 변환

```
0.1 = 0.000110011001100110011... (2진법)
```

이진수로 변환하면 **무한히 반복되는 소수**가 됩니다.

#### 2. 정규화
이진수 부동소수점은 항상 1.xxxx × 2^n 형태로 표현됩니다. <br/>
이를 위해 소수점을 첫 번째 1 뒤로 이동시켜야 하죠.

```
0.000110011001100110011... 
```

첫 번째 1이 **소수점 뒤 4번째 자리**(2⁻⁴ 자리)에 있습니다.

따라서, 소수점을 **오른쪽으로 4자리 이동**시켜서 1.xxxx 형태로 만듭니다:

```
0.000110011001100110011... 
= 1.10011001100110011... × 2⁻⁴
```

> **정규화란?** 항상 **1.xxxx × 2^n** 형태로 만드는 것입니다.
> - 오른쪽으로 4자리 이동 → 2⁻⁴를 곱해줌
> - 왼쪽으로 3자리 이동 → 2³을 곱해줌

#### 3. 각 필드 계산

**부호**: 양수이므로 `0`

**지수**: -4 + 127(바이어스) = 123

```
123 = 01111011 (2진법)
```

> **왜 Bias를 더하나요?**  
> 지수는 양/음수 모두 가능하지만, 저장은 **부호 없는 정수(Unsigned Integer)** 로 해야 합니다.  
> 그래서 32비트에서는 127을 더해 `-126~127` → `0~255`로 표현합니다.  
>
> 참고로, 127은 **8비트 지수의 중간값 (2⁷ - 1)** 이기도 합니다 !

**분수 부분**: 1. 뒤의 23비트
```
10011001100110011001100
```

#### 4. 결과
```
0 01111011 10011001100110011001100
```

하지만 23비트로는 무한 반복되는 패턴을 완전히 표현할 수 없으므로,
실제로 저장되는 값은 **근사값**입니다.

### 64비트 부동소수점 (Double)

비트 수가 늘어나면, **더 많은 숫자를 더 정밀하게** 표현할 수 있습니다 !

<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/64bit_Float.png"
  width="800"
/>

- 더 높은 정밀도
- 지수 바이어스: 1023
- 지수 범위: -1022~1023

> 예를 들어, 0.1처럼 32비트로는 정확하게 표현하기 어려운 수들도,  
> 64비트에선 훨씬 더 **근사치 오차를 줄여서 저장**할 수 있습니다.

---

## 부동소수점 오차로 인한 실제 사례들

### 1991년, 패트리어트 미사일의 실패

걸프 전쟁 당시, 미국의 패트리어트 미사일 시스템이 **부동소수점 오차**로 인해 치명적인 참사로 이어졌습니다.

**문제의 원인**   
- 시스템 가동 시간을 1/10초 단위로 측정
- 1/10 = 0.1을 24비트 고정소수점으로 표현
- 0.1의 실제 저장값: 0.09999999999534
- 100시간 후 누적 오차: 약 0.34초

**결과**  
날아오는 스커드 미사일을 요격해야하는데, 스커드 미사일의 예상 위치가 실제보다 687미터 벗어나 실패.  
미군 28명이 사망함.

### 1996년, 아리안 5호 로켓의 폭발

유럽우주기구(ESA)의 아리안 5호 로켓이 **발사 37초 만에  공중 폭발**했습니다.

**문제의 원인**  
- 64비트 부동소수점 값을 16비트 정수로 강제 변환
- 수평 속도 값이 16비트 범위 초과
- 소프트웨어 예외 발생 → 시스템 종료 → 비행 제어 상실

**손실**  
개발비 **5억 달러** 증발

### 2012년, 나이트 캐피털의 알고리즘 거래 실패

미국의 대형 증권사, 나이트 캐피털은 **자동 매매 알고리즘의 반올림 오차**로 인해  
단, **45분 만에 4억 4천만 달러**의 손실을 보았습니다.

**문제의 원인**   
- 부동소수점 연산 중 잘못된 반올림 처리
- 주문량 계산에 오류 발생
- 정상 가격보다 수백 배 비싼 가격에 매수 주문 발생
- 주식 시장에 혼란 유발

**결과**  
기업 파산 직전까지 몰리며 결국, 타사에 인수됨.


---

## 그래서 어떻게 해결하나요 ?

실제 생명이나 막대한 금액이 달린 시스템에서 부동소수점 오차는 큰 문제를 일으킬 수 있습니다.  
하지만, 일상적인 계산에서는 반올림만으로도 충분한 경우가 많습니다.

<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/runjscode.png"
  width="800"
/>

```javascript
console.log((0.1 + 0.2).toFixed(1));      // "0.3"
```

그런데 이게 정말 정확한 0.3은 아닙니다.  
toFixed는 문자열 포맷일 뿐, 내부적으로 오차 자체는 여전히 존재합니다.

하지만, 그냥 반올림으로 타협을 보는 겁니다.  
왜냐하면 **사람이 눈으로 확인하기에** 보기 좋은 숫자이기 반올림으로 타협을 본 것입니다.

**언제 더 정확한 계산이 필요하나요 ?**
- 금융 시스템, 수백억 원이 오가는 계좌 간 이채
- 항공우주, 위성 궤도 계산에서의 미세한 시간 차이
- 과학 계산, 시뮬레이션에서의 에너지 보존
- 실시간 제어, 자동차 ABS 제어처럼 밀리초 단위가 중요한 경우

이런 경우에는 **센트 단위로 정수 계산**을 하거나, **전용 라이브러리**를 사용합니다.

---

## 부동소수점의 특수값

IEEE 754는 숫자 외에도 특수한 값들을 정의합니다.  

개발을 하면서 결과값으로 Infinity, NaN을 종종 보셨을 겁니다.  
하지만, 이런 값들도 IEEE 754에서 정의된 **공식적인 값**입니다.

### Infinity (무한대)

0으로 나누거나, 표현할 수 있는 수의 범위를 초과하면 `Infinity`가 발생합니다.

```javascript
console.log(1 / 0);        // Infinity
console.log(-1 / 0);       // -Infinity
```

### NaN (Not a Number)

정의되지 않은 연산의 결과입니다.

```javascript
console.log(0 / 0);        // NaN
console.log(NaN === NaN);  // false
```

NaN은 자기 자신과도 같지 않다고 정의되어 있어서, `false` 값이 나옵니다.

---

## 완벽함의 한계

> "All models are wrong but some are useful." - 통계학자 George E. P. Box

컴퓨터의 부동소수점 시스템도 마찬가지로, 완벽하지 않지만, 충분히 유용합니다.

NASA가 달에 로켓을 보내고,  
날씨를 예측하고,  
3D 게임을 실행하고,  
AI가 그림을 그리는 것도 모두 이 '불완전한' 시스템 덕분입니다.

### 왜 IEEE 754가 성공했는가?

1. **표준화** : 모든 플랫폼에서 동일한 결과
2. **하드웨어 지원** : CPU에 내장된 고속 연산
3. **범용성** : 과학 계산부터 게임까지 광범위한 용도
4. **효율성** : 메모리와 계산 속도의 적절한 균형

### 정확성 vs 효율성

만약 모든 계산을 완벽하게 정확히 하려면?
- 메모리가 몇 배로 필요함.
- 계산 속도가 현저히 느려짐.
- 배터리도 빨리 닳음.

그래서 전 세계가 합의한 겁니다.  
**"조금 부정확하더라도, 빠르고 효율적인 게 낫다"** 고.

---

## 마무리

컴퓨터가 0.1 + 0.2를 제대로 계산하지 못하는 건 버그가 아니라, **수학의 한계**이자 **표현의 한계**입니다.  
무한한 숫자를 유한한 공간에 욱여넣으려다 보니 생긴 일이죠.  

하지만 이 `불완전한 시스템` 덕분에 우리는 유튜브도 보고, 게임도 하고, 카카오톡도 할 수 있습니다.  
완벽하지 않아도 **충분히 유용하고 효율적입니다.**