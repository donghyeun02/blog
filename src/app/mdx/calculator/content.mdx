<img
  src="https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2025-07-02+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+11.25.22.png"
  width="400"
  height="320"
/>

누구나 한 번쯤 써봤던 계산기, 7 + 5 누르면 12가 나오고, 실수하면 AC 버튼 눌러서 초기화하고.<br/>
그냥 숫자만 더해주는 단순한 기계 같지만, 사실 계산기는 굉장히 정교한 디지털 시스템입니다.

계산기를 쓰면서 문득 이런 생각이 드신 적 있으신가요?

> "이거... 안에 뭐가 들어 있는 거지?"

단순히 디스플레이만 달린 전자식 주판의 개념인 줄 알았는데, 아니었습니다.<br/>
그 안에는 컴퓨터 공학에서 배우는 핵심 구조가 다 들어 있어요.

- 이진수 있음.
- 논리 회로 당연히 있음.
- 레지스터, ALU, 디코더 다 들어감.

계산기는 실제로 컴퓨터 구조의 축소판이라고 볼 수 있습니다.

---

## "계산기는 0과 1로 이루어져 있다는 사실, 알고 계셨나요?"

우리가 버튼을 눌러 입력한 숫자들은 계산기 안에선 전부 0과 1로 바뀝니다.<br/>
이건 마치 컴퓨터가 쓰는 언어 같은 거라고 볼 수 있습니다.

사람은 '7' 이라 쓰지만, 컴퓨터는 '0111' 이라는 코드로 기억하는 식이죠.<br/>
결국 계산기는 숫자를 코드로 바꾸고, 그걸 처리해서 다시 사람이 이해할 수 있는 숫자로 바꿔 보여주는 겁니다.

### 7은 어떻게 0111이 될까요?

- 2³ × 0 = 0
- 2² × 1 = 4
- 2¹ × 1 = 2
- 2⁰ × 1 = 1
- 4 + 2 + 1 = 7

<DecimalToBinaryConverter />

이렇게 변환된 이진수는 논리 연산 회로에서 본격적으로 계산에 사용됩니다.

### 왜 0과 1일까?

계산기나 컴퓨터는 전기로 동작합니다. <br/>
전류가 흐르면 '켜짐(ON)', 흐르지 않으면 '꺼짐(OFF)' 상태죠.<br/>

이걸 숫자로 바꾸면 아래 표와 같이 표현할 수 있습니다.

| 상태        | 의미     |
| ----------- | -------- |
| 전류 흐름 O | 1 (High) |
| 전류 흐름 X | 0 (Low)  |

바로 이 '켜짐(1)'과 '꺼짐(0)'이 컴퓨터의 언어인 이진수가 된 겁니다.

<div className="not-prose w-full overflow-x-auto">
  <BufferGateSimulator />
</div>

그래서 컴퓨터는 복잡한 연산도 결국 0과 1, 이 두 가지 상태만으로 해냅니다.<br/>
딱 두 개니까 회로도 단순하게 설계할 수 있고, 전자적으로 안정적이기도 하죠.

**'0 아니면 1', '참 아니면 거짓', 'OFF 아니면 ON'** 이런 구조 덕분에 컴퓨터는 지금처럼 빠르고 정확하게 작동할 수 있는 겁니다.

---

## 이진수 덧셈은 어떻게 이루어질까?

계산기에서 3 + 2 를 누르면 내부에선 아래와 같은 계산이 이뤄집니다.

```
  0 1 1 (3)
+ 0 1 0 (2)
-------
  1 0 1 (5)
```

이진수 덧셈의 규칙:

1. 0 + 0 = 0
2. 0 + 1 = 1
3. 1 + 0 = 1
4. 1 + 1 = 10 (올림수 발생)

하지만 이걸 사람이 하는 게 아니니까, 계산기는 이 규칙을 논리 회로로 구현해 놓습니다.<br/>
이때 나오는 게 바로 Half Adder(반가산기)와 Full Adder(전가산기)입니다.

---

### 1비트 덧셈의 시작, Half Adder

Half Adder(반가산기)는 두 개의 1비트 입력(A, B)을 받아서 합(Sum)과 올림수(Carry)를 출력합니다.

#### Half Adder의 구조

- **입력**: A, B (각각 1비트)
- **출력**:
  - Sum
  - Carry

**진리표**

<TruthTable
  headers={['A', 'B', 'Sum', 'Carry']}
  rows={[
    [0, 0, 0, 0],
    [0, 1, 1, 0],
    [1, 0, 1, 0],
    [1, 1, 0, 1],
  ]}
  outputStartIndex={2}
/>

<HalfAdderSimulator />

**논리식**

- Sum = A ⊕ B (XOR)
- Carry = A · B (AND)

### Half Adder의 한계

Half Adder는 두 비트만 더할 수 있어서, 실제 여러 자리 덧셈에선 문제가 있습니다.<br/>
이전 자리에서 올라온 올림수를 처리할 수 없거든요.

예를 들어, 111 + 111 같은 계산을 해보면:

```
  1 1 1
+ 1 1 1
-------
```

오른쪽부터 계산할 때:

- 첫 번째 자리: 1 + 1 = 0 (올림수 1)
- 두 번째 자리: 1 + 1 + **이전 올림수 1** = ?

Half Adder는 이 "**이전에서 올라온 올림수**"를 처리할 수 없어요.

### Half Adder 두 개로 Full Adder 만들기

그래서 Half Adder 두 개와 OR 게이트를 연결하여 이 문제를 해결할 수 있습니다.

이때 올림수를 구분해서 부르게 됩니다:

- **Carry-in (Cin)** : 이전 자리에서 들어오는 올림수
- **Carry-out (Cout)** : 다음 자리로 내보내는 올림수

1. **첫 번째 Half Adder** : A와 B를 더함
2. **두 번째 Half Adder** : 첫 번째 결과와 **Carry-in(Cin)** 을 더하여 Sum
3. **OR 게이트** : 두 Half Adder에서 나온 올림수들을 합쳐서 최종 **Carry-out(Cout)** 생성

> 💡 입력 순서는 위에서부터 Cin → A → B입니다.

<FullAdderFromHalfAddersSimulator />

### 완성된 Full Adder 회로

이렇게 만든 회로가 바로 **Full Adder(전가산기)** 입니다.
Full Adder는 A, B 외에도 이전 자리에서 올라온 Carry-in(Cin) 까지 입력으로 받아 처리합니다.

#### Full Adder의 구조

- **입력**: A, B, Cin (각각 1비트)
- **출력**:
  - Sum
  - Cout

**진리표**

<TruthTable
  headers={['A', 'B', 'Cin', 'Sum', 'Cout']}
  rows={[
    [0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 1, 0, 1],
    [1, 0, 0, 1, 0],
    [1, 0, 1, 0, 1],
    [1, 1, 0, 0, 1],
    [1, 1, 1, 1, 1],
  ]}
  outputStartIndex={3}
/>

<FullAdderSimulator />

**논리식**

- Sum = A ⊕ B ⊕ Cin
- Cout = (A · B) + (B · Cin) + (A · Cin)

### 여러 비트를 처리하려면?

계산기에서 다루는 숫자는 당연히 1비트보다 훨씬 큽니다.
그래서 여러 개의 Full Adder를 이어 붙여 훨씬 큰 비트 수 연산을 합니다.

```
  11001 (25)
+ 10111 (23)
--------
 110000 (48)
```

이런 방식으로 진짜 덧셈이 계산기 안에서 이루어집니다.

---

## 입력부터 출력까지

이제 계산기 내부에서 어떤 일이 일어나는지 하나씩 따라가 보겠습니다.

### 버튼을 누르면 어떤 일이 벌어질까?

예를 들어, 숫자 7 버튼을 누르면,

- 해당 키를 눌렀다는 전기 신호가 발생합니다.
- 내부적으로 키 매트릭스 회로가 작동해 어느 키가 눌렸는 지 식별합니다.
- 이 값은 이진수(7 -> 0111)로 변환되어 연산을 위해 레지스터에 저장됩니다.

> 💡 이 시점부터 계산기는 오직 0과 1 만으로 작동합니다. 모든 정보는 전류가 흐르는가(1) 아닌가(0)로 표현됩니다.

### 계산의 핵심 (ALU, Arithmetic Logic Unit)

입력된 숫자들이 준비되면, 계산기의 ALU가 작동합니다.<br/>
ALU는 실제 연산을 담당하는 컴퓨터 내부 부품으로, 내부에서는 Full Adder 회로를 통해 자릿수별 연산이 진행됩니다.<br/>
복잡해 보이지만, 결국 덧셈이나 뺄셈 같은 기본 연산을 담당하는 계산 블록이라고 생각하면 됩니다.

7 + 5의 경우

- 7 (0111)과 5 (0101)가 ALU로 전달됩니다.
- ALU 내부의 Full Adder 회로들이 자릿수별로 덧셈을 수행합니다.
- 결과는 다시 레지스터에 저장되거나 출력 회로로 전달됩니다.

> ALU는 계산기의 '두뇌'와 같습니다. CPU에도 이 ALU가 포함되어 있고, 계산기의 ALU는 그 축소판이라고 볼 수 있습니다.

### 결과는 어떻게 보여줄까?

계산 결과는 다시 십진수로 변환되어 디스플레이 출력됩니다.

- 이진수 -> BCD(Binary-Coded Decimal) 변환
- BCD -> 7-Segment Decoder를 통해 LED/LCD 디스플레이 제어
- 결과적으로 '12', '-3' 등 사람이 읽을 수 있는 숫자 형태로 화면에 출력

> 이 단계는 단순한 변환이 아니라, 전기 신호 -> 문자 코드 -> 시각 정보로 바꾸는 복잡한 흐름입니다.

---

## 계산기는 작지만, 정교한 디지털 시스템이다.

정리하자면,

> 숫자 몇 개 더하다가 컴퓨터 구조의 핵심을 다 배우게 되는 기기.

- 계산기의 모든 연산은 0과 1의 조합으로 이뤄지고
- Full Adder는 덧셈의 기본 단위로 쓰이며
- 입력부터 출력까지 모든 흐름은 논리 회로로 구성된다.

계산기는 단순한 계산 도구를 넘어서, 디지털 시스템의 원리를 담은 작은 실습 장치라고 볼 수도 있습니다.<br/>
이런 방식으로 계산이 진행된다는 걸 알게 된 순간, 계산기가 대단해보이고 사용할 떄 느낌이 달라집니다.. 😄
