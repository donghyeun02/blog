<img
  src = "https://donghyeun-blog-images.s3.us-east-1.amazonaws.com/metaMask.png"
  width = "600px"
/>

## window.ethereum?

DApp 관련 코드들을 살펴보면 꼭 이런 코드들이 있다.

```javascript
if (window.ethereum) {
  // 블록체인 관련 로직
}
```

처음 봤을 땐 좀 어리둥절했다.

"아니 그냥 블록체인 API 호출하면 되는 거 아닌가? <br />
왜 굳이 window.ethereum 같은 걸 확인하지?"

보통 자바스크립트에서 API를 쓸 때는 fetch나 axios처럼 내가 직접 요청보내고, 서버에서 응답받으면 끝이다. <br />
근데 이건 무슨 브라우저 전역 객체에 달린 ethereum부터 확인하라는 게 무슨 소리인가 싶었다.

---

## 단순한 데이터가 아니다

결론은 window.ethereum은 브라우저가 원래 제공하는 기능이 아니다. <br />
이건 MetaMask 같은 지갑 확장 프로그램이 **Ethereum provider**라는 인터페이스를 브라우저에 주입해놓은 것이다.

즉, 개발자가 만든 것도 아니고, 크롬이 기본으로 넣어준 것도 아니다. <br />
지갑이 브라우저에 꽂아둔 전용선 같은 거다.

내 브라우저는 평소처럼 웹만 보여주는 게 아니라, 그 순간부터는 <br />
이더리움 네트워크랑 연결된 선을 하나 더 달고 있는 셈이다.

---

## EIP-1193 표준

이 provider는 아무렇게나 만들어진 게 아니다. <br />
EIP-1193 (Ethereum Provider JavaScript API) 라는 표준이 있어서, <br />
대부분의 지갑 (메타마스크, 코인베이스 월렛 등)이 같은 방식으로 window.ethereum을 주입한다.

- `ethereum.request(args)` → JSON-RPC 요청을 보낼 수 있는 메인 메서드
- 이벤트 시스템 지원 (`on`, `removeListener`)

즉, provider는 그냥 하나의 **JSON-RPC 게이트웨이**다. <br />
DApp이 블록체인에 "내 잔액좀 알려줘", "이 계정으로 트랜잭션 날려줘" 같은 메세지를 보낼 수 있게 해주는 것이다.

---

## Provider vs Signer

- **Provider**: 블록체인 데이터 읽기 (잔액, 블록 번호, 네트워크 상태 확인)
- **Signer**: 내 개인키로 트랜잭션에 서명

window.ethereum은 기본적으로 provider 역할을 하고, <br />
거기에 지갑 확장 익스텐션이 signer 기능을 얹어서 읽기는 자유롭지만, 쓰기는 반드시 내 동의가 필요하다.

---

## 보안적 함의

그러면 왜 꼭 `if (window.ethereum)`을 체크해야 할까? <br />
보안을 생각해보면 답이 나온다.

- 만약 지갑이 없다면? → window.ethereum 자체가 없으니 블록체인 관련 로직은 실행 불가
- 만약 악성 확장이 가짜 provider를 심는다면? → 사용자의 트랜잭션을 가로채거나, 잘못된 네트워크로 보낼 수 있다.

실제로 피싱 사이트 중에서 진짜 window.ethereum을 흉내내서 가짜 지갑처럼 작동되는 경우가 있다고 한다. <br />
사용자가 아무 의심 없이 버튼을 누르면, 승인했다는 착각과 함께 자산이 다 털려버리는 것이다.

그래서 대부분의 라이브러리는 window.ethereum.isMetaMask 같은 속성을 확인해서, <br />
이 provider가 어떤 지갑에서 온 건지 식별한다.

단순히 있는지 없는지만 보는 게 아니라, "누가 설치한 provider"인지까지 확인하는 절차인 것이다.


### 기본적인 연결 확인
```javascript
if (typeof window.ethereum !== 'undefined') {
  console.log('지갑이 설치되어 있습니다!');
} else {
  console.log('지갑을 설치해주세요');
}
```

### 계정 요청
```javascript
try {
  const accounts = await window.ethereum.request({
    method: 'eth_requestAccounts'
  });
  console.log('연결된 계정:', accounts[0]);
} catch (error) {
  if (error.code === 4001) {
    console.log('사용자가 연결을 거부했습니다');
  }
}
```

### 네트워크 정보 확인
```javascript
const chainId = await window.ethereum.request({
  method: 'eth_chainId'
});
console.log('현재 네트워크:', chainId);
```

---

## 결국엔

처음엔 굳이 써야 하나 싶던 전역 객체였던 window.ethereum은 알고보니 지갑이 브라우저에 꽂아둔 provider였다.

결국 window.ethereum은 그냥 "데이터 객체"가 아니었다. <br />
이건 EIP-1193 표준에 맞춰 지갑이 주입한 provider이고, <br />
DApp ↔ 지갑 ↔ 블록체인 사이에 놓인 전용 인터페이스였다.

그래서 튜토리얼이나 예제 코드마다 `if (window.ethereum)`으로 시작하는 건 괜히 그런 게 아니었다. <br />
지갑이 없다면 연결조차 못 하고, 지갑이 있어야만 블록체인 관련 로직을 실행시킬 수 있는 것이다.
